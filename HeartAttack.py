# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RNWz8Wlor_0fJaMPeRlcV6yd35Fl_C4t
"""

import torch
import torchvision
import torch.nn as nn
import pandas as pd
import matplotlib.pyplot as plt
import torch.nn.functional as F
from torchvision.datasets.utils import download_url
from torch.utils.data import DataLoader, TensorDataset, random_split

import matplotlib.pyplot as plt
import seaborn as sns
import plotly.figure_factory as ff

heart = pd.read_csv('./heart.csv')
sat = pd.read_csv('./o2Saturation.csv')

heart

heart.describe

plt.figure(figsize=(15,10))
corr = heart.corr()
sns.heatmap(corr,annot=True)

sns.set_theme()
sns.color_palette("flare", as_cmap=True)
sns.displot(heart['chol'], legend=True, kde = True, palette="flare", color="green")

sns.set_theme()
sns.color_palette("flare", as_cmap=True)
sns.displot(heart['thalachh'], legend=True, kde = True, palette="flare", color="blue")

hist_data = [heart['chol'],heart['thalachh']]
group_labels = ['chol', 'thalachh'] # name of the dataset

fig = ff.create_distplot(hist_data, group_labels)
fig.show()

df_p=sns.PairGrid(heart,hue="output")
df_p.map(plt.scatter)

df_p=sns.PairGrid(heart,hue="output")
df_p.map_diag(sns.displot, multiple="stack", element="step")

def dataframe_to_arrays(dataframe, input_cols, output_cols, categorical_cols):
    """
    Convert DataFrame to numpy array. 
    Parameters
    ----------
    dataframe        : pd.DataFrame
    input_cols       : list
    output_cols      : list
    categorical_cols : list

    Returns 
    -------
    numpyArrays
    """
    # Make a copy of the original dataframe
    dataframe1 = dataframe.copy(deep=True)
    # # Convert non-numeric categorical columns to numbers
    for col in categorical_cols:
        dataframe1[col] = dataframe1[col].astype('category').cat.codes
    # Extract input & outupts as numpy arrays
    inputs_array = dataframe1[input_cols].to_numpy()
    targets_array = dataframe1[output_cols].to_numpy()
    return inputs_array, targets_array

input_cols = [item for item in heart.columns if item != 'output']
output_cols = ['output']
categorical_cols = []
input_array, target_array = dataframe_to_arrays(heart, input_cols, output_cols, categorical_cols)

inputs = torch.from_numpy(input_array).type(torch.float32)
targets = torch.from_numpy(target_array).type(torch.float32)

inputs.size(), targets.size()

inputs.dtype, targets.dtype

val_size = int(len(heart)*0.1)
train_size = len(heart)-val_size

dataset = TensorDataset(inputs, targets)

type(dataset)

train_ds, val_ds = random_split(dataset,[train_size,val_size])

batch_size = 32

from torch.utils.data import DataLoader

train_loader = DataLoader(train_ds, batch_size, shuffle=True)
val_loader = DataLoader(val_ds, batch_size)

class heartAttack(nn.Module):
    def __init__(self, input_size, output_size):
        super().__init__()
        self.linear1 = nn.Linear(input_size,output_size)
        
    def forward(self, xb):
        out = self.linear1(xb)
        return out

    def training_step(self, batch):
        inputs, targets = batch 
        # Generate predictions
        out = self(inputs)          
        # Calcuate loss
        loss = F.l1_loss(out,targets)
        return loss
    
    def validation_step(self, batch):
        inputs, targets = batch
        # Generate predictions
        out = self(inputs)
        # Calculate loss
        loss = F.l1_loss(out,targets)
        # acc = accuracy(out,targets)
        # print(acc)
        return {'val_loss': loss.detach() }# , 'val_acc':acc}
        
    def validation_epoch_end(self, outputs):
        batch_losses = [x['val_loss'] for x in outputs]
        epoch_loss = torch.stack(batch_losses).mean()
        return {'val_loss': epoch_loss.item() }

    def epoch_end(self, epoch, result, num_epochs):
        # Print result every 20th epoch
        if (epoch+1) % 20 == 0 or epoch == num_epochs-1:
            print("Epoch [{}], val_loss: {:.4f}".format(epoch+1, result['val_loss']))

PATH = './model'

model = heartAttack(13,1)

def evaluate(model, val_loader):
    """
    Evaluate the val loss of the model we trained.
    
    Parameters
    ----------
    model      : LR model we trained
    val_loader : DataLoader
    
    Results
    -------
    dictionary
    """
    outputs = [model.validation_step(batch) for batch in val_loader]
    return model.validation_epoch_end(outputs)

def accuracy(outputs, labels):
    """
    Calculate the accuracy of the trained model.
    Parameters
    ----------
    outputs : torch.tensors
    labels  : torch.tensors

    Returns
    -------
    int
    """
    _, preds = torch.max(outputs, dim=1)
    # preds = torch.as_tensor((preds - 0.4) > 0, dtype=torch.int32)
    # labels = torch.as_tensor(labels, dtype=torch.int32)
    labels = [torch.as_tensor(label, dtype=torch.int32) for label in labels]
    preds = [torch.as_tensor(out, dtype=torch.int32) for out in preds]
    count = 0
    for i in range(len(labels)):
        try:
          if labels[i] == preds[i]:
            count = count + 1
        except:
          pass
    return (count/len(preds))*100

def train(epochs, model, train_loader, val_loader, optimizer):
    history = []
    min = float('inf')
    for epoch in range(epochs):
        # Training Phase
        for batch in train_loader:
            optimizer.zero_grad()
            loss = model.training_step(batch)
            loss.backward()
            optimizer.step()
            
        # Validation phase
        result = evaluate(model, val_loader)
        print(result)
        if min > result['val_loss']:
            min = result['val_loss']
            torch.save(model.state_dict(), PATH)
        history.append(result)
    return history

evaluate(model, val_loader)

import torch.optim as optim 
optimizer = optim.Adam(model.parameters())

history = train(100,model, train_loader, val_loader, optimizer)

model.load_state_dict(torch.load(PATH))

for i, j in zip(train_loader, val_loader):
  print(i, j)
  break

def predict_single(input, target, model):
    inputs = input.unsqueeze(0)
    predictions = model(input)                # fill this
    prediction = predictions[0].detach()
    print("Input:", input)
    print("Target:", target)
    print("Prediction:", torch.as_tensor((prediction - 0.4) > 0, dtype=torch.int32))
    return (torch.as_tensor((prediction - 0.4) > 0, dtype=torch.int32)==torch.as_tensor(target, dtype=torch.int32))

input, target = val_ds[6]
predict_single(input, target, model)

def predict_single(input, target, model):
    inputs = input.unsqueeze(0)
    predictions = model(input)                # fill this
    prediction = predictions[0].detach()
    print("Input:", input)
    print("Target:", target)
    print("Prediction:", torch.as_tensor((prediction - 0.4) > 0, dtype=torch.int32))

def get_accuracy(dataset):
    count = 0
    for i in range(len(dataset)):
        input, target = dataset[i]
        inputs = input.unsqueeze(0)
        predictions = model(input)                # fill this
        prediction = predictions[0].detach()
        if torch.as_tensor((prediction - 0.4) > 0, dtype=torch.int32)==torch.as_tensor(target, dtype=torch.int32):
            count = count + 1
    return {'accuracy' : 100*count/len(dataset) }

get_accuracy(val_ds)

def plot_losses(history):
    train_losses = [x.get('train_loss') for x in history]
    val_losses = [x['val_loss'] for x in history]
    plt.figure(figsize=(10,5))
    plt.plot(train_losses, '-bx')
    plt.plot(val_losses, '-rx')
    plt.xlabel('epoch')
    plt.ylabel('loss')
    plt.legend(['Training', 'Validation'])
    plt.title('Loss vs. No. of epochs');

plot_losses(history)

def predict_result(age, sex,	cp,	trtbps,	chol,	fbs,	restecg,
                   thalachh,	exng,	oldpeak,	slp,	caa,	thall):
    """
    Parameters
    ----------
    age      : int
    sex	     : int
    cp	     : int
    trtbps	 : int
    chol	   : int
    fbs	     : int
    restecg	 : int
    thalachh : int
    exng	   : int
    oldpeak	 : int
    slp	     : int
    caa	     : int
    thall    : int

    Results
    -------
    boolean
    """
    data = []
    data.append({'age':age,
                 'sex':sex,
                 'cp':cp,
                 'trtbps':trtbps,
                 'chol':chol,
                 'fbs':fbs,
                 'restecg':restecg,
                 'thalachh':thalachh,
                 'exng':exng,
                 'oldpeak':oldpeak,
                 'slp':slp,
                 'caa':caa,
                 'thall':thall})
    input_a = pd.DataFrame(data).to_numpy()
    input = torch.from_numpy(input_a).type(torch.float32)
    dataset = TensorDataset(input)
    # inputs = dataset[0][0].unsqueeze(0)
    predictions = model(dataset[0][0])
    return torch.as_tensor((predictions - 0.4) > 0, dtype=torch.int32) > 0

predict_result(age = 63, sex= 1,cp=	3,trtbps=	145,chol=233,fbs=	1,restecg=0,thalachh=	150,exng=0,oldpeak=2.3,slp=0,caa=0,thall=1)